#!/usr/bin/bash
## Author: Simon D. Woodtli
## Project: https://github.com/SimonWoodtli/cmd-zet
## License:  Apache-2.0
#
## TODO anything that returns one line like `zet get` should also be xcliped
## __functionName() = main function called from user input
## _functionName()  = sub function only called from within a main function
shopt -s extglob
########################### global variables ###########################
declare red=$'\033[31m'
declare black=$'\033[30m'
declare green=$'\033[32m'
declare yellow=$'\033[33m'
declare blue=$'\033[34m'
declare magenta=$'\033[35m'
declare cyan=$'\033[36m'
declare white=$'\033[37m'
declare reset=$'\033[0m'
declare bold=$'\033[1m'

## global variables also get sourced from configFile
declare configFile="$HOME/.config/zet/config"
declare zetDir
declare -A commands
declare -a orderCommands
declare subcommand
############################## config init #############################
__configInit() {
  ## update version (maintainer only)
  ## before I commit a new git tagged version I nejj
  cd "$GHREPOS/myrepos/cmd-zet" || return 1
  ## Get the latest git tag
  local latestTag="$(git tag | sort -V | tail -n 1)"
  ## Set the hardcoded value for version (users)
  local currentVersion="v0.0.1"
  ## check if they differ if so update version
  #
  ## TODO this actually needs testing once i release and git tag repo
  ## Problem test1:
  ## first test wouldnt work it only updates the config file for maintainer
  ## a sed command is required to get this done and replace the hardcoded
  ## var line
  #[[ "$currentVersion" == "$latestTag" ]] || currentVersion="$latestTag"
  ## PROBLEM test2: 
  ## the user won't have them equal because latestTag will be empty var for them
  ## Can I actually use sed on the script that I exec on itself? testing
  #[[ "$currentVersion" == "$latestTag" ]] || sed -i "s|local currentVersion=.*|local currentVersion=$latestTag|" "$GHREPOS/myrepos/cmd-zet/zet"

  ## check if zet config dir exists or create it
  [[ -d "${configFile%config}" ]] || mkdir -p "${configFile%config}"
  ## dump config data into file
  _configData | sort > "$configFile"
}
_configData() {
  ## change these settings to your needs
  cat <<EOF
editor=vim
current=public
zetPublicDir=$HOME/Repos/github.com/SimonWoodtli/zet
zetPrivateDir=$HOME/Private/zet
downloadDir=$HOME/Downloads
screenshotDir=$HOME/Pictures
scriptName="${0##*/}"
version=$currentVersion
EOF
}
############################# crucial tests ############################
## Check Bash Version: Only compare Major Version Number
[[ "${BASH_VERSION:0:1}" -gt 4 ]] || { echo "${yellow}Warning:$reset This script requires Bash version 4+"; exit 1; }
## Check dependencies:
_checkDependencies() {
  ## ImageMagick is also a dependency: `identify` is part of this toolbox
  local -a dependencies=( fzf fd rg sed awk identify xclip git gnome-screenshot )
  local -a missingDependencies
  for dependency in "${dependencies[@]}"; do
    command -v "$dependency" >/dev/null 2>&1 || missingDependencies+=( "$dependency" )
  done
  if [[ -n "${missingDependencies[*]}" ]]; then
    echo "${red}ERROR:$reset Missing dependency(ies): ${bold}${missingDependencies[*]}$reset"
    exit 1
  fi
}
_checkDependencies
#set -e
## test if configfile exits if not run the initialize command
[[ -f "$configFile" ]] || __configInit
## load configFile variables to global variables
source "$configFile"
## read config file if current is set to public set zetDir to path of public zet.
## Else set it to path of private zet.
[[ "$current" == public ]] && zetDir="$zetPublicDir" || zetDir="$zetPrivateDir"

## If no argument is passed into `zet` run initialize
[[ $# -ne 0 ]] || __configInit
############################## config cmds #############################
__configPrintCurrentZetDir() { echo "$current" ; }
__configUseZet() {
  ## case for arguments passed into it from associative array "commands" value.
  ## see title: main
  case "$1" in
    public|Public) sed -i 's|current=.*|current=public|' "$configFile" ;;
    private|Private) sed -i 's|current=.*|current=private|' "$configFile" ;;
    *) echo "${yellow}Warning:$reset only values accepted: private, public"
  esac
}
############################### utilities ##############################
_isoSec() { date -u +%Y%m%d%H%M%S; }
_urlencode() {
  local keywords="$1"
  local keywordsEncoded
  for (( i=0; i<${#keywords}; i++ )); do
    [[ "${keywords:$i:1}" =~ [[:blank:]] ]] && keywordsEncoded+="%20" || keywordsEncoded+="${keywords:$i:1}"
  done
  ## bash can only return exit status, this is the next best thing I figured
  echo "$keywordsEncoded"
}
_newest() {
  local IFS=$'\n'
  ## create array "f" and sort elements by time, also ${1:-.}/*
  ## lists files with absolute path where $1 would simply list files
  mapfile -t f < <(ls -1 --color=never -trd "${1:-.}"/*)
  #local -a f=($(ls -1 --color=never -trd ${1:-.}/*))
  ## print the last element of array
  echo "${f[-1]}"
}
################################ create ################################
__create() {
  ## create file
  local dir="$zetDir/$(_isoSec)" #absolute path
  local readme="$dir/README.md" #absolute path
  local title="$*"
  mkdir -p "$dir"
  printf "# %s\n\n" "$title" > "$readme"
  ## edit file
  _createEditFile
  ## push file to remote git repo
  _createPushGit
}
_createEditFile() { "$editor" "$readme" ; }
_createPushGit() {
  ## check if readme.md is empty, if so abort git commands
  [[ -s "$readme" ]] || return 1
  cd "$dir" || return 1
  ## check if title has changed after editing if so reassign it
  local newTitle="$(head -1 "$readme" | sed 's|#\+ *||')"
  [[ "$title" == "$newTitle" ]] || title="$newTitle"
  ## check if title string is not empty or exit
  test -n "$title"
  git pull -q
  echo "${green}Committing:$reset ${bold}$title${reset}"
  git add -A "$dir" &>/dev/null
  git commit -m "$title" &>/dev/null
  git push &>/dev/null
}
__createScreenshot() {
  local isoSec="$(_isoSec)"
  local dir="$zetDir/$isoSec" #absolute path
  local readme="$dir/README.md" #absolute path
  local title="$*"
  ## test if title is not empty
  [[ -n "$title" ]] || { echo "${blue}Hint:$reset Missing title. Use ${bold}\`zet screenshot <title>\`$reset"; exit 1; }
  mkdir -p "$dir" || { echo "${red}Error:$reset Unable to create directory ${bold}$dir${reset}">&2; exit 1; }
  ## create screenshot, if you like to use another tool replace the gnome-screenshot command
  gnome-screenshot -a 2>/dev/null || { echo "${red}Error:$reset Unable to create screenshot."; exit 1; }
  ## get latest created screenshot path
  local imagePath=$(_newest "$screenshotDir") #absolute path
  ## find out the images width and height
  local width=$(identify -format %w "$imagePath" 2>/dev/null)
  local height=$(identify -format %h "$imagePath" 2>/dev/null)
  ## imagePath can also refer to a dir if no Screenshot gets created.
  ## Then it moves the whole dir into your Zettel this test prevents this.
  ## This test checks if a width|height exists else it exits
  [[ -n "$width" || -n "$height" ]] || { echo "${red}ERROR:$reset Screenshot width or height could not be identified. Did you actually create a screenshot?"; exit 1; }
  local imageName="Screenshot-$isoSec-${width}x${height}.png"
  ## mv image into new Zettel dir and rename it
  mv "$imagePath" "$dir/$imageName" || { echo "${red}Error:$reset Unable to move screenshot."; exit 1; }
  ## print content into readme
  printf "%s\n\n%s\n" "# ðŸ–¼ï¸ $title" "![]($imageName)" > "$readme"
  ## test if new zettel folder is not more than 1MB otherwise exit
  local dirSize="$(\du -s "$dir" | awk '{print $1}')"
  [[ "$dirSize" -le 1000 ]] || { echo "${red}Error:$reset Screenshot size is limited to 1MB. Zettel: ${bold}${dir##*/}${reset}" >&2; exit 1; }
  ## commit and push files to git remote
  exit
  _createPushGit
}
############################ search commands ###########################
__printReferenceLinkLines() {
  [[ -z "$1" ]] && echo "${blue}Hint:$reset Missing search query. Use ${bold}\`zet link <searchterm>\`$reset" && return 1
  local -a addLinkLine=()
  local -i i=0
  ## create ripgrep keyword string with pipes. The idea is that if multiple
  ## keywords are being used they are filtered with an AND logic.
  local keywords="$*"
  local keywordRgLine
  for keyword in $keywords; do
    keywordRgLine+="rg -i --no-heading $keyword|"
  done
  ## remove the last pipe from string
  keywordRgLine="${keywordRgLine%|}"
  ## loop over all dir in zetDir
  for dir in "$zetDir"/*; do
    ## grab title of current zetdir empty variable if keyword not found.
    filterFirstLine="$(head -n1 "$dir/README.md" 2>/dev/null | eval "$keywordRgLine" | sed 's|#[[:blank:]]||')"
    ## if it already finds keyword in title skip checking the tagline. To
    ## avoid double entries
    if [[ -n "$filterFirstLine" ]]; then
      ## add title to array
      addLinkLine[$i]="* [${dir##*/}](/${dir##*/}/) $filterFirstLine"
      i+=1
      ## skip rest of loop. loop over next zetdir
      continue
    fi
    ## store last line
    filterLastLine="$(tail -n 1 "$dir/README.md" 2>/dev/null | eval "$keywordRgLine" )"
    ## check if last line has same structure to tagline
    if [[ "$filterLastLine" =~ ^[[:blank:]]{4}\#.*$ ]]; then
      ## add the tagline title to array
      addLinkLine[$i]+="* [${dir##*/}](/${dir##*/}/) $(head -n1 "$dir/README.md" 2>/dev/null | sed 's|#[[:blank:]]||')"
      i+=1
    fi
  done
  printf '%s\n' "${addLinkLine[@]}"
}
__printGithubQueryLine() {
  local keywords="$*"
  #_urlencode "$keywords"
  [[ -z "$1" ]] && echo "${blue}Hint:$reset Missing search query. Use ${bold}\`zet query <searchterm>\`$reset" && return 1
  local link="https://github.com/$GITUSER/$scriptName/search?q=$(_urlencode "$keywords")"
  echo "[$keywords]: <$link>"
}
################################# stuff ################################
__editLastModifiedReadme() {
  ## Q: What is better performance wise?
  ## Method 1: Two loops, seems more sane less command repetition
  ##loop: list all files with modification timestamp
  local lastModifiedReadmeDate="$( for f in "$zetDir"/*/README.md; do         \
    date -r "$f" +"%Y-%m-%d-%H-%M-%S"; done                                   \
    | sort -n                   `#once loop finished sort those timestamps`   \
    | tail -n 1)"                #filter by last entry
  ## loop again with mod timestamp and check which timestamp matches the
  ## last entry of the first loop. If found store file location
  for f in "$zetDir"/*/README.md; do
    modifiedReadmeDate=$(date -r "$f" +"%Y-%m-%d-%H-%M-%S")
    [[ "$modifiedReadmeDate" == "$lastModifiedReadmeDate" ]] && local readme="$f"
  done
  ## edit readme and if changes are made git push them
  _editReadme
  ## Method 2: One loop that invokes subshell at every iteration
  #local -a modifiedReadme=()
  #local -i i=0
  #local lastModifiedReadme
  #for f in "$zetDir"/*/*; do
  #  readmePath+=( "$f" )
  #  modifiedReadme+=( "$(date -ur "$f" +"%Y%m%d%H%M%S")" )
  #  sorted=($(printf '%s\n' "${modifiedReadme[@]}"|sort|tail -n 1))
  #  [[ "$sorted" -eq "${modifiedReadme[$i]}" ]] && lastModifiedReadme="${readmePath[$i]}"
  #  i+=1
  #done
}
__countReadme() { fd . "$zetDir" --type d | wc -l ; }
__version() { echo "$version"; }

############################# help commands ############################
__usage() {
  ## associative arrays are unordered for this loop to work order is
  ## required hence the second regular array 'orderCommands'
  printf "%s\n\n" "${yellow}COMMANDS:$reset"
  for (( i=0; i < ${#orderCommands[@]}; i+=1 )); do
    key="${orderCommands[$i]}"
    [[ "$i" -ge 11 ]] && echo "    zet $key <pattern>" && continue
    echo "    zet $key"
  done
}
__help() {
  cat <<EOF
${yellow}NAME:$reset
    zet - a command line tool to manage a git Zettelkasten repository.

${yellow}INSTALL:$reset
    Installation instructions can be found on the project's website.

${yellow}USAGE:$reset
    zet [OPTIONS] [<subcommand>] [<pattern>]...

${yellow}ARGS:$reset
    ${green}<subcommand>$reset
          The subcommand which invokes different functionalities to manage Zettel (notes).
    ${green}<pattern>$reset
          The pattern for some subcommands to search keywords, add title etc.

${yellow}OPTIONS:$reset
    ${green}-h$reset, ${green}--help$reset
          Show help information
    ${green}-v$reset, ${green}--version$reset
          Show version information
    ${green}-u$reset, ${green}--usage$reset
          List all commands

${yellow}ABOUT:$reset
    Project: https://github.com/simonwoodtli/cmd-zet
    Author: Simon Donald Woodtli <simonwoodtli@posteo.net>
EOF
}
##################### fzfSelect dependent functions ####################
__fzfSelect() {
  ## filter and merge lines
  local -a mergeTitleTag=()
  local -i i=0
  for f in "$zetDir"/*; do
    filterLastLine="$(tail -n 1 "$f"/README.md 2>/dev/null)"
    filterFirstLine="$(head -n1 "$f"/README.md 2>/dev/null)"
    #echo "$(tail -n 1 "$f"/README.md 2>/dev/null)"
    mergeTitleTag[$i]="$filterFirstLine"
    if [[ "$filterLastLine" =~ ^[[:blank:]]{4}\#.*$ ]]; then
      mergeTitleTag[$i]+="$filterLastLine"
    fi
    i+=1
  done
  ##TODO  make fzf dependent zet functions run inside vim like :Rg or the like
  ## `!!zet get` maybe won't work with !! magic wands. but something like the
  ## commands that ship with fzf e.g. :Rg should be possible to do.
  ##ðŸ›TODO if fzfSelect runs and you hit Ctrl-C abort signal it prints shit or
  ## even opens random README.md with `zet edit`
  ## fzf select title with tags at the end of title
  ##TODO make this an array so multiple files can be selected
  ##IMPORTANT!!creating this feature with array will cost a lot of overhead many
  ## loops will be needed for the other edit and delete functions that
  #want to utilize this??
  local selectTitleLine="$(for element in "${mergeTitleTag[@]}"; do           \
    echo "$element"; done                                                     \
    | fzf-tmux --no-preview  -w 80% -h 70% --prompt="zet search: "`#pipe each Title and possible Tagline into fzf`  \
    | sed -r 's|[[:blank:]]{4}#[a-z].*$||g')" #remove the tags from string
  ## absolute path to readme file
  local readme="$( rg --no-heading -N -l -x --type md "$selectTitleLine" "$zetDir" )"
  ## absolute path to dir, remove README.md suffix
  local dir="${readme%/*}"

  ## case for arguments passed into it from associative array "commands" value.
  ## see title: main
  case  "$1" in
  ## edit file from fzf selection
    edit) _editReadme ;;
    delete) _deleteReadme;;
    get) _printDirPath ;;
    body) _printBodyReadme ;;
    cat) _printReadme ;;
  esac
}
_printReadme() { cat "$readme" ; }
_printBodyReadme() {
  ## test if readme has tagline if yes remove last 3 lines and first two
  ## lines for the title. Else just remove the first two lines
  local bodyReadme
  ## although shellcheck doesn't like this if else logic with A && B ||
  ## C. If B and C are var assignments this shouldn't be a problem.
  ## https://github.com/koalaman/shellcheck/wiki/SC2015
  [[ $(tail -n 1 "$readme") =~ ^[[:blank:]]{4}\#.*$ ]]                        \
    && bodyReadme="$( head -n -3 "$readme" | tail -n +3 )" `#rm tag and title`\
    || bodyReadme="$( tail -n +3 "$readme")"                #rm title
  echo "$bodyReadme"
}
_printDirPath() { echo "$dir" ; }
_deleteReadme() { rm -rf "$dir" ; _deletePushGit ; }
_deletePushGit() {
  ## TODO create an array from all the selected files
  #local -a deletedZet=( "$( git ls-files --deleted )" )
  cd "$zetDir" || return 1
  local dirIsoSec="${dir##*/}"
  local title="Delete $dirIsoSec"
  ## check if dirIsoSec string is empty if so exit
  test -n "$dirIsoSec"
  git pull -q
  echo "${green}Committing:$reset ${bold}$title${reset}"
  git add -A "$dir" &>/dev/null
  git commit -m "$title" &>/dev/null
  git push &>/dev/null
}
_editReadme() {
  "$editor" "$readme"
  exit
  _editPushGit
}
_editPushGit() {
  cd "$dir" || return 1
  ## TODO check if any changes where made, if not abort git
  #??
  ## assign title
  local title="$(head -1 "$readme" | sed 's|#\+ *||')"
  ## check if title string is empty if so exit
  test -n "$title"
  git pull -q
  echo "${green}Committing:$reset ${bold}$title${reset}"
  git add -A "$dir" &>/dev/null
  git commit -m "$title" &>/dev/null
  git push &>/dev/null
}
################################# main #################################
## create associative array with key value pairs
## since associative array come unordered another regular array is needed too
commands[init]="__configInit";                    orderCommands+=("init")
commands[current]="__configPrintCurrentZetDir";   orderCommands+=("current")
commands[last]="__editLastModifiedReadme";        orderCommands+=("last")
commands[delete]="__fzfSelect delete";            orderCommands+=("delete")
commands[edit]="__fzfSelect edit";                orderCommands+=("edit")
commands[get]="__fzfSelect get";                  orderCommands+=("get")
commands[body]="__fzfSelect body";                orderCommands+=("body")
commands[cat]="__fzfSelect cat";                  orderCommands+=("cat")
commands[count]="__countReadme";                  orderCommands+=("count")
commands[help]="__help";                          orderCommands+=("help")
commands[version]="__version";                       orderCommands+=("version")
commands[usage]="__usage";                        orderCommands+=("usage")
commands[screenshot]="__createScreenshot";        orderCommands+=("screenshot")
## command with <patterns>
commands[use]="__configUseZet";                   orderCommands+=("use")
commands[create]="__create";                      orderCommands+=("create")
commands[link]="__printReferenceLinkLines";       orderCommands+=("link")
commands[query]="__printGithubQueryLine";         orderCommands+=("query")
## case for options/flags
case "$1" in
  --help|-h) __help;;
  --usage|-u) __usage;;
  --version|-v) __version;;
esac
subcommand="$1"; shift
## loop over keys and check if they match user input, if so exec
## function call from $1 argument
for key in "${!commands[@]}"; do
  if [[ "$key" == "$subcommand" ]]; then
    eval "${commands[${key}]}" "$@"
    exit 0
  fi
done
######################### Tab Completion Context ########################
## Tab completion - add to bashrc: complete -C zet zet
if [ -n "$COMP_LINE" ]; then
  for cmd in "${!commands[@]}"; do
    [[ "${cmd:0:${#1}}" == "$1" ]] && echo $cmd
  done
  exit 0
fi
